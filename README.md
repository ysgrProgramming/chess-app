# Project Design: Cursor × GitHub CLI "Self-Validating" AI Development Ecosystem

## 1\. 概要 (Executive Summary)

本プロジェクトは、AIコードエディタ **Cursor** と **GitHub CLI**、そして **CI (GitHub Actions)** を組み合わせ、論理的整合性と品質を担保しながらソフトウェア開発を行う「半自律型AI開発エコシステム」の設計書です。

このシステムの核心は、単一のAIにすべてを任せるのではなく、**「要件定義」「管理・レビュー」「実装」という3つの役割（ロール）を明確に分割し、システム的に手順を強制する**点にあります。これにより、LLM特有の「幻覚（ハルシネーション）」や「自己正当化」を防ぎ、人間の関与を最小限かつ高レイヤーな意思決定のみに集中させます。

## 2\. コアコンセプト (Core Concepts)

### A. 役割の分断とコンテキストの分離

一人の人間に二重人格を演じさせるのではなく、\*\*完全に独立したチャットセッション（コンテキスト）\*\*で異なる役割をAIに実行させます。

- **Architect:** 曖昧なアイデアを尋問し、定義書に落とし込む。
- **Manager:** 実装コードを書かず、仕様管理とレビューに徹する（長期記憶）。
- **Engineer:** Issueごとに生成され、タスク完了と共に破棄される（短期記憶）。

### B. CIによる客観的バリデーション

AIの「動くはずです」という言葉は信用しません。
**GitHub Actions** 上で `make test` (単体テスト) と `make lint` (静的解析) が通過しない限り、プルリクエスト（PR）のレビュー段階に進むことをシステム的に禁止します。

### C. Human-in-the-Loop の定型化

人間は「AIの思考」には介入しません。人間が行うのは以下の2点のみです。

1.  **承認と意思決定**（GO/NO-GOの判断）
2.  **物理的なスイッチング**（AIからの「指示サイン」に従い、適切なエージェントを呼び出す）

## 3\. ロール定義 (Role Definitions)

システムは `.cursor/rules/*.mdc` によって定義される以下の3つのロールで構成されます。

| ロール                            | 担当フェーズ                           | 振る舞い・権限                                                                                                                                                      |
| :-------------------------------- | :------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Architect**<br>(`ai-architect`) | 企画・要件定義                         | **「尋問官」**<br>人間からの入力が曖昧な場合、`REQUIREMENT.md` が埋まるまで質問を繰り返す。定義が完了するまで実装フェーズへの移行を許可しない。                     |
| **Manager**<br>(`ai-manager`)     | タスク分解<br>レビュー<br>メタチェック | **「PM兼レビュアー」**<br>要件定義からIssueを作成する。PRに対し、コードそのものではなく「論理と要件の整合性」をレビューする。プロジェクト全体の設計歪みを検知する。 |
| **Engineer**<br>(`ai-engineer`)   | 実装<br>テスト                         | **「使い捨て実装者」**<br>Issue単位で起動する。TDD（テスト駆動開発）を厳守し、PR作成時にはコードの変更理由を論理的に解説する義務を持つ。                            |

## 4\. アーキテクチャ構成 (Architecture)

- **Interface:** Cursor (Composer機能)
- **Context Control:** ロールごとに「New Chat」を行い、コンテキストを汚染させない。
- **Communication:** GitHub Issue / PR (全ての決定事項と議論はここに集約)
- **Tools:**
  - `gh` (GitHub CLI): AIによるIssue/PRの操作
  - `make`: テスト・Lintコマンドの統一
  - `GitHub Actions`: CIによる品質ゲート

## 5\. 運用フロー (Workflow)

### Phase 0: 要件定義 (Architect)

1.  人間が「こういうアプリを作りたい」と Architect を呼び出す。
2.  Architect は `REQUIREMENT.md` のテンプレートに基づき、不足情報を人間にヒアリングする。
3.  全ての定義が埋まったら、Manager への引き継ぎサインを出す。

### Phase 1: タスク分解 (Manager)

1.  Manager は要件定義書を読み込み、実装可能な粒度の `task` Issue に分解して登録する。
2.  最初の Issue に着手するためのプロンプトを人間に提示する。

### Phase 2: 実装 (Engineer)

1.  人間は「Issue \#X をやって」と Engineer を呼び出す（**必ずNew Chat**）。
2.  Engineer は以下の厳格なループを実行する：
    - **TDD:** テスト作成 → 失敗(Red) → 実装 → 成功(Green)
    - **Lint:** `make lint` の通過
    - **Isolation:** `.env` 等の秘匿情報には触れない。実験コードはコミットしない。
3.  PRを作成する。この際、\*\*「要件ごとの論理的解決策（Self-Walkthrough）」\*\*を記述する。

### Phase 3: レビュー (Manager)

1.  **CI (GitHub Actions)** が自動実行される。失敗したPRはレビュー対象外。
2.  Manager はPRを読み、以下を確認する：
    - CIがGreenであるか。
    - PRの「論理的解決策」が理にかなっているか。
    - Diffが要件を満たしているか。
3.  問題なければマージ（Approve）、問題があれば修正指示（Reject）。

### Phase 4: メタレビュー (Manager)

1.  マージ完了後、Manager は「今回の変更がアーキテクチャ全体に悪影響（歪み）を与えていないか」を診断する。
2.  リファクタリングが必要と判断した場合、自らは修正せず、新たな `refactor` Issue を作成してバックログに積む。

## 6\. インターフェース仕様 (Human Interaction)

人間が迷わず操作できるよう、AIはアクションが必要なタイミングで必ず以下の\*\*「アクションブロック」\*\*を表示します。

```markdown
::: action 🛑 人間の操作が必要です
**状況:** [現在のステータス (例: PR作成完了)]
**操作:** [次に人間がすべき物理操作 (例: New Chatを開く)]
**次のプロンプト:**
(ここにあるテキストをコピーして、次のチャットに入力するだけ)

> @ai-manager.mdc PR #15 のレビューをお願いします。
> :::
```

## 7\. ディレクトリ構造 (Project Structure)

```text
root/
├── .cursor/
│   └── rules/              # 各AIロールの振る舞い定義 (.mdc)
│       ├── ai-architect.mdc
│       ├── ai-manager.mdc
│       ├── ai-engineer.mdc
│       └── tech-stack.mdc  # 技術選定・コーディング規約
├── .github/
│   ├── workflows/          # CI定義 (push時に test/lint 実行)
│   ├── ISSUE_TEMPLATE/     # タスク定義用テンプレート
│   └── PULL_REQUEST_TEMPLATE.md # Self-Walkthrough記述用
├── REQUIREMENT.md          # アーキテクトが管理する要件定義書
├── ROADMAP.md              # マネージャーが管理する進捗表
├── Makefile                # コマンド集約 (test, lint)
└── src/                    # ソースコード
```

## 8\. 安全装置と制約 (Guardrails)

1.  **TDD & Lint 強制:** ローカルで `make test` `make lint` が通らないコードはPush禁止。さらにCIでダブルチェックを行う。
2.  **シーケンシャル処理:** 複数のIssueを同時に進行させない。常に「1つのIssue、1つのEngineerセッション」で完結させ、コンテキストの混濁を防ぐ。
3.  **秘匿情報の保護:** AIには `.env` などのCredentialファイルへのアクセス権限を与えず、モックデータでのテストを原則とする。

## 9\. 開発環境セットアップ (Development Setup)

### 前提条件

- **Node.js**: バージョン 20.0.0 以上が必要（`package.json`の`engines`フィールドを参照）
- **npm**: Node.jsに付属し、PATHに含まれていること

### セットアップ手順

1. **依存関係のインストール**

   ```bash
   make setup
   # または
   npm install
   ```

2. **動作確認**
   ```bash
   make test    # すべてのテストが通過することを確認
   make lint    # Lintエラーがないことを確認
   ```

### トラブルシューティング

**問題: `make test`や`make lint`が`npm: command not found`エラーを出す**

- **原因**: `npm`がPATHに含まれていない
- **解決策**:
  - Node.jsが正しくインストールされているか確認: `node --version`、`npm --version`
  - nvmを使用している場合、シェルの設定ファイル（`.bashrc`、`.zshrc`など）でnvmが自動的にロードされるように設定してください
  - または、手動で`source ~/.nvm/nvm.sh`を実行してから`make`コマンドを実行してください

**問題: CI（GitHub Actions）でテストが失敗する**

- **原因**: CI環境でNode.jsが正しくセットアップされていない
- **解決策**: CIの設定（`.github/workflows/ci.yml`）でNode.jsのバージョンを指定してください

## 10\. ローカル2人対戦の操作例 (Usage Example)

1. **アプリを起動する**  
   `npm run dev` (または `vite`) を実行し、ブラウザでアプリを開きます。初期状態では「White's turn」が表示され、白番から開始します。
2. **駒を動かす**  
   - クリック: 動かしたい駒→移動先のマスの順にクリックします。合法手のみ受け付けられ、相手番の駒は選択できません。  
   - ドラッグ&ドロップ: 駒をドラッグして目的のマスにドロップすることも可能です。  
   - 選択中の駒にはハイライトが表示され、合法手のマスにはガイドが描画されます。
3. **ターン管理**  
   画面左上のターンインジケータが常に現在の手番を示します。手番でない駒は移動できず、常に交互に進行します。
4. **棋譜（Move List）の活用**  
   - `Move List` にはSAN表記の棋譜が蓄積されます。任意の手をクリックするとその時点の局面へジャンプし、kifuの先をプレビューできます。  
   - プレビュー中に新しい手を指すと、以降の手は破棄され、選択していた手番のプレイヤーから分岐を再開できます。
5. **Undo / Reset**  
   - `Undo`: 直前の手を一手だけ巻き戻します（ターンも自動で追従）。  
   - `New Game`: 盤面と棋譜をリセットし、再び白番から開始します。
6. **ローカル対戦フロー (Flow 1)**  
   1. アプリ起動後すぐに白番が指し、続いて黒番が同じデバイスで指します。  
   2. 詰み／やり直しを確認したいときは `Undo` や `Move List` を使って局面を巻き戻し、必要に応じて新しい変化を入力します。  
   3. いつでも `New Game` で初期局面から再開でき、棋譜は自動クリアされます。

この手順に従うことで、アカウントなし・ネットワークなしで2人が1台のデバイスを共有し、完全な対局を実行できます。
